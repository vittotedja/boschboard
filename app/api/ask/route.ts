// app/api/ask/route.ts
import { createClient } from "@supabase/supabase-js";
import OpenAI from "openai";
import { NextRequest, NextResponse } from "next/server";
import { z } from "zod";

// Initialize Supabase and OpenAI clients
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// Helper function to run a Supabase query generated by GPT.
// WARNING: Using eval is unsafe. In production, consider a more controlled parser.
async function runSupabaseQuery(gptQuery: string): Promise<any> {
  // Remove the "supabase." prefix if it exists to avoid duplication.
  if (gptQuery.startsWith("supabase.")) {
    gptQuery = gptQuery.replace(/^supabase\./, "");
  }
  // Now evaluate the query string by prepending "supabase." back.
  // For example, if GPT returns: from('calibration_records').select('actual_calibration_interval, last_calibration_date').eq('Serial_or_Id_no', '8972X5XY')
  // Then we evaluate: supabase.from('calibration_records')...
  // eslint-disable-next-line no-eval
  const queryFn = eval(`supabase.${gptQuery}`);
  const { data, error } = await queryFn;
  if (error) {
    throw new Error(error.message);
  }
  return data;
}

export async function POST(req: NextRequest) {
  try {
    const { question } = await req.json();
    if (!question) {
      return NextResponse.json(
        { error: "No question provided." },
        { status: 400 }
      );
    }

    let finalAnswer: string | null = null;
    const maxAttempts = 3;
    let parsedResponse: any = null;

    // Try up to maxAttempts to obtain a valid answer or query
    for (let i = 0; i < maxAttempts; i++) {
      // Step 1: Ask GPT to produce either a direct answer or a query.
      const gptResponse = await openai.chat.completions.create({
        model: "gpt-4o",
        temperature: 0,
        messages: [
          {
            role: "system",
            content: `
You have access to these PostgreSQL tables via Supabase:

calibration_records(Description, Serial_or_Id_no, actual_calibration_interval, last_calibration_date, Calibration_error)
measurement_records(prod_id, tool_desc, tool_id, measurement_mm, timestamp)
products(description, serial_id, model_no, size_mm, tolerance_limit_mm, cost)
tools(Description, Brand, Tag, Model_or_Part_No, Serial_or_Id_no, Ext_or_Int_Cal, Calibrator, Cost)

Today's date is: ${new Date().toISOString().split("T")[0]}

User's question: "${question}"

Instructions:
1) If the question can be answered without querying the database, return valid JSON:
   {"type": "answer", "answer": "your answer text"}
2) If the question requires data from the database, return valid JSON:
   {"type": "query", "query": "a valid supabase-js query chain expression. Only the query chain is needed."}
Return only the JSON without any extra text.
`
          },
          {
            role: "user",
            content: question,
          },
        ],
      });

      const content =
        gptResponse.choices[0].message?.content?.trim() || "";
	  console.log(content)
      try {
        parsedResponse = JSON.parse(content);
      } catch (err) {
        // If parsing fails, continue to next attempt.
		console.log(err)
        continue;
      }
	  console.log(parsedResponse);
      // If GPT provided a direct answer, use it.
      if (parsedResponse.type === "answer") {
        finalAnswer = parsedResponse.answer;
        break;
      }

      // If GPT returned a query, attempt to run it.
      if (parsedResponse.type === "query" && parsedResponse.query) {
        try {
          const dbData = await runSupabaseQuery(parsedResponse.query);
		  console.log(dbData);
          // Step 3: Pass the database results back to GPT for a final answer.
          const secondResponse = await openai.chat.completions.create({
            model: "gpt-4o",
            temperature: 0,
            messages: [
              {
                role: "system",
                content: `
We have the following data from the database (in JSON):
${JSON.stringify(dbData, null, 2)}

User's question: "${question}"

Based on the data above, please provide a final answer to the user's question.
`
              },
              {
                role: "user",
                content: question,
              },
            ],
          });

          finalAnswer =
            secondResponse.choices[0].message?.content?.trim() || "";
          break;
        } catch (dbError: any) {
          // If the query fails, ask GPT to fix the query using the error message.
		  console.log(dbError);
          const errorFixResponse = await openai.chat.completions.create({
            model: "gpt-4o",
            temperature: 0,
            messages: [
              {
                role: "system",
                content: `
Your previous query caused an error: "${dbError.message}"
Please correct the query and return valid JSON:
{"type": "query", "query": "a valid supabase-js query expression"}
`
              },
              {
                role: "user",
                content: question,
              },
            ],
          });
          const fixContent =
            errorFixResponse.choices[0].message?.content?.trim() || "";
          try {
            parsedResponse = JSON.parse(fixContent);
            // Continue to next loop iteration to try the new query.
          } catch (err) {
            continue;
          }
        }
      }
    }

    // If no final answer was produced, return a fallback message.
    if (!finalAnswer) {
      finalAnswer = "I'm sorry, I couldn't process your request.";
    }

    return NextResponse.json({ answer: finalAnswer });
  } catch (error: any) {
    console.error("API error:", error);
    return NextResponse.json(
      {
        error: "An error occurred while processing your request.",
        details: error.message,
      },
      { status: 500 }
    );
  }
}
